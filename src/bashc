#!/bin/bash
function usage() {
  cat <<EOF

This is a tool that tries to flatten bash applications. It is useful if you use source statements
  to organize your files. In this case, this tool will make a single file with no outern dependencies.

  The application also includes one tool to try to remove unused functions (strip-functions). This
  is useful to create libraries with a lot of funcions in it, but only include those that are used in
  the resulting application.

$0 <options>
  --execute|-e              Execute the resulting file (it admits parameters at the end)
  --chdir|-c <folder>       Changes the working directory to the one provided as a parameter
                            (i.e. cd <folder> ... cd -)
  --chdir-to-file|-C        Changes the working directory to the one in which the file is
                            (in case that the file is in other folder)
  --file|-f <filename>      Outputs the resulting process to the file <filename>
  --skipmissing|-s          Skips the files that could not be found when detecting the command
                            source. Otherwise the app will stop if cannot find the file to include
  --onlyonce|-o             The app will try to detect the "source" statements only once. Take
                            into account that if one sourced file also includes a "source" statement,
                            using this mode it will not be sourced.
  --strip-functions|-S      Try to remove the unused functions (useful to create minimal commands)
  --verbose | -v            Shows more information about the procedure.
  --debug                   Shows a lot more information about the procedure.
  --help | -h               Shows this help and exits.
  
EOF
}

# Some basic includes
source lib/debug.bash
source lib/temp.bash
source lib/utils.bash
source lib/config.bash
source lib/parameters.bash
source version

# Parse the commandline into an array
bashc.parameter_parse_commandline "$@"

function getfunctions_fnc() {
echo "$1" | awk '
  /^[ \t]*function (.*)/{
    match($0, /^[ \t]*function ([^{(]+).*{.*/, arr)
    fncname=arr[1]
    print fncname
  }
' 
}

function strip_fnc() {
# https://stackoverflow.com/a/33516495
RESTOFCODE='
  infunction {
    analized_str=$0;
    
    # if in double quote, remote anything up othe double quote
    if (in_dquote==1)
      if (sub(/^[^"\\]*(\\.[^"\\]*)*"/,"", analized_str)) in_dquote=0;

    # if in single quote, remote anything up the single quote
    if (in_squote==1)
      if (sub(/^[^'"'"']*'"'"'/,"", analized_str)) in_squote=0;

    # if still in double quote or single quote, skip
    if (in_dquote || in_squote) next;

    # Remove quoted sentences
    while (sub(/"[^"\\]*(\\.[^"\\]*)*"|'"'"'[^'"'"']*'"'"'/,"",analized_str));

    # Remove anything from the single quote (or the double quote)
    if (index(analized_str, "\"")< index (analized_str, "'"'"'")) {
      if (sub(/"[^"\\]*(\\.[^"\\]*)*$/,"", analized_str))
        in_dquote=1;
      else    
        if (sub(/'"'"'[^'"'"']*$/,"", analized_str)) 
          in_squote=1;
    }  else {
      if (sub(/'"'"'[^'"'"']*$/,"", analized_str))      
        in_squote=1;
      else    
        if (sub(/"[^"\\]*(\\.[^"\\]*)*$/,"", analized_str))
          in_dquote=1;
    }

    # Remove comments (beware of the {#arr[@]} bash expansion)
    sub(/[^{]#.*$/,"",analized_str);

    # If it is empty, skip
    if (match(analized_str,/^[ \t]*$/)) next;

    # Count number of { and } in line
    b += split(analized_str, tmp, "{");
    b -= split(analized_str, tmp, "}");

    # If there are no more braces, we have finished
    if (b<=0) infunction = 0;

    # If we had more closing braces, it is a bug in the original file
    next;
  }
'
echo "$2" | awk "
  /^[ \t]*function [ \t]*$1[ \t\({].*/{
    infunction=1;
    b=0; # The factor between open / close brackets
    in_squote=0;
    in_dquote=0;
  }
  /^[ \t]*$/{ # Remove empty lines
    next;
  }
  $RESTOFCODE
  1 # Print line"
}

TMPDIR=
OUTFILE=
FILETOJOIN=
WORKINGFOLDER=.
PARAMS=()
n=0

DEBUG=
EXECUTE=true
ONLYONCE=false
SKIPMISSING=false
STRIPFUNCTIONS=false

bashc.parameters_start
while bashc.parameters_next; do
  PARAM="$(bashc.parameter_current)"
  case "$PARAM" in
    --folder|-f)            bashc.parameters_next
                            WORKINGFOLDER="$(bashc.parameter_current)";;
    --chdir-to-file-folder|-C)     
                            CHDIRTOFILE=true;;
    --output|-o)            bashc.parameters_next
                            OUTFILE="$(bashc.parameter_current)";;
    --compile|-c)           EXECUTE=false;;
    --skipmissing|-s)       SKIPMISSING=true;;
    --include-once|-O)      ONLYONCE=true;;
    --verbose|-v)           VERBOSE=true;;
    --debug)                DEBUG=true;;
    --help | -h)            usage && bashc.finalize;;
    --strip-functions | -S) STRIPFUNCTIONS=true;;
    --|*)                   [ "$PARAM" == "--" ] && bashc.parameters_next
                            while ! bashc.parameters_end; do
                              PARAM="$(bashc.parameter_current)"
                              if [ "$FILETOJOIN" == "" ]; then
                                FILETOJOIN="$PARAM"
                              else
                                PARAMS+=("$PARAM")       
                              fi                      
                              bashc.parameters_next     
                            done;;
  esac
  n=$(($n+1))
done

if [ "$FILETOJOIN" == "" ]; then
  bashc.finalize 0 "no input file provided"
fi

if [ "$OUTFILE" == "-" ]; then
  OUTFILE=""
fi

# Change to the working folder (get it from the file, if flag -C is set)
if [ "$CHDIRTOFILE" == "true" ]; then
  WORKINGFOLDER="$(dirname "$FILETOJOIN")"
  FILETOJOIN="$(basename "$FILETOJOIN")"
fi

cd "$WORKINGFOLDER" || bashc.finalize 1 "not valid working folder $WORKINGFOLDER"

# Prepare
_FILES_INCLUDED=()
_TMPFILE1="$(bashc.tempfile)"
cp "$FILETOJOIN" "$_TMPFILE1"
HAVEWORK=true

# Will have work while some "source" statements are detected
while [ "$HAVEWORK" == "true" ]; do
  _NXT_SRC="$(cat "$_TMPFILE1" | sed 's/#.*//g' | sed 's/^[ \t]*//g' | sed 's/[ \t]*$//g' | sed '/^$/d' | grep '^source ' | head -n 1)"
  if [ "$_NXT_SRC" != "" ]; then
    _TMPFILE2=$(bashc.tempfile)
    _SRC_FILE="$(bashc.trim "${_NXT_SRC:7}")"

    if [ -e "$_SRC_FILE" ]; then
      SOLVEINCLUDE=true
      FILEINCLUDED="$(echo "${_FILES_INCLUDED[@]}" | grep "$_SRC_FILE")"
      if [ "$FILEINCLUDED" != "" ]; then
        if [ "$ONLYONCE" == "true" ]; then
          p_warning "file $_SRC_FILE has already been included"
          SOLVEINCLUDE=false
        fi
      fi
      if [ "$SOLVEINCLUDE" == "true" ]; then
        p_debug "including file $_SRC_FILE"
        _CONTROLFIELD="$(cat /proc/sys/kernel/random/uuid)"
        sed -e "0,/^$(bashc.sanitize "$_NXT_SRC")\$/s//$_CONTROLFIELD/"  -e "/$_CONTROLFIELD/ {
        r $_SRC_FILE
        a
        d
        }" "$_TMPFILE1" > "$_TMPFILE2" 
        _FILES_INCLUDED+=("$_SRC_FILE")
      else
        p_debug "skipping file $_SRC_FILE"
        cat "$_TMPFILE1" | sed "s/^\\($(bashc.sanitize "$_NXT_SRC")\\)\$/# Already included: \\1/" > "$_TMPFILE2"
      fi
    else
      p_warning "could not find file $_SRC_FILE"
      if [ "$SKIPMISSING" == "true" ]; then
        cat "$_TMPFILE1" | sed "s/^\\($(bashc.sanitize "$_NXT_SRC")\\)\$/# Missing file: \\1/" > "$_TMPFILE2"
      else
        bashc.finalize 1 "could not find file $_SRC_FILE"
      fi
    fi
    mv "$_TMPFILE2" "$_TMPFILE1"
  else
    HAVEWORK=false
  fi
done

function remove_unused_functions() {
  local REMOVED CURRENT_CONTENT STRIPPED_CONTENT FOUND_CONTENT
  local FUNCTIONS="$(getfunctions_fnc "$F_CONTENT" | tr '\n' ' ')"
  p_debug "functions: 
  $FUNCTIONS"

  CURRENT_CONTENT="$1"
  local i=0
  for f in $FUNCTIONS; do
    STRIPPED_CONTENT="$(strip_fnc "$f" "$CURRENT_CONTENT")"
    FOUND_CONTENT="$(echo "$STRIPPED_CONTENT" | grep "\b$f\b")"
    if [ "$FOUND_CONTENT" == "" ]; then
      p_debug "removing function '$f'"
      CURRENT_CONTENT="$STRIPPED_CONTENT"
      REMOVED=true
    else
      p_debug "keeping function '$f'"
    fi
    #p_debug "$i -----------------------------------------------------------"
    #p_debug "$CURRENT_CONTENT"
    #p_debug "$i ==========================================================="
    i=$((i+1))
  done
  echo "$CURRENT_CONTENT"
  if [ "$REMOVED" == "true" ]; then
    return 1
  fi
  return 0
}

# Now let's strip the functions
if [ "$STRIPFUNCTIONS" == "true" ]; then
  p_debug "$_TMPFILE1"
  F_CONTENT="$(cat "$_TMPFILE1")"
  REPEAT=true

  while [ "$REPEAT" == "true" ]; do
    F_CONTENT="$(remove_unused_functions "$F_CONTENT")"
    if [ $? -eq 0 ]; then
      REPEAT=false
      p_debug "no more changes"
    fi
  done

  echo "$F_CONTENT" > "$_TMPFILE1"
fi

if [ "$OUTFILE" != "" ]; then
  mv "$_TMPFILE1" "$OUTFILE"
else
  if [ "$EXECUTE" == "true" ]; then
    OUTFILE="$_TMPFILE1"
  else
    cat "$_TMPFILE1"  
  fi
fi

if [ "$EXECUTE" == "true" ]; then
  bash -- "$OUTFILE" "${PARAMS[@]}"
fi

cd - > /dev/null